<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="robots" content="index, follow">
        
        <link rel="alternate" type="application/rss+xml" title="RSS" href="https://commentari.dev/rss.xml">
        
        <title>Commentari | A first foray into Arrow (Part 1: Python)</title>

        <link rel="preload" href="https://commentari.dev/css/style.css" as="style">
        <link rel="stylesheet" href="https://raw.githack.com/Speyll/suCSS/main/reset-min.css" crossorigin="anonymous">
        <link rel="stylesheet" href="https://raw.githack.com/Speyll/suCSS/main/suCSS-min.css" crossorigin="anonymous">
        <link rel="stylesheet" href="https://commentari.dev/css/style.css">
        <link rel="stylesheet" href="https://commentari.dev/css/custom.css">
	<style>
        pre {
          max-height: none;       /* don't clip vertically */
          overflow-y: visible;    /* no vertical scrollbar */
          overflow-x: auto;       /* allow horizontal scroll if needed */
          white-space: pre;       /* preserve spacing, don't wrap lines */
        }

        pre code {
          white-space: inherit;   /* keep same handling inside <code> */
        }
	</style>

        <!-- Add favicon with appropriate sizes -->
        <link rel="icon" href="https:&#x2F;&#x2F;commentari.dev&#x2F;/favicon.ico">
        
    </head>
    <body>
        
        
        
        
	<nav id="nav-bar" style="gap:0.65rem;">
            
            <a href="&#x2F;" class="">
                
                Home
            </a>
            
            <a href="&#x2F;software&#x2F;" class="">
                
                Software
            </a>
            
            <a href="&#x2F;maths&#x2F;" class="">
                
                Maths
            </a>
            
            <a href="&#x2F;philosophia&#x2F;" class="">
                
                Philosophia
            </a>
            

            <div class="theme-toggle" id="theme-toggle" role="button" tabindex="0" aria-label="Toggle theme"
                data-icon-base="https://commentari.dev/icons.svg"
                data-icon-dark="#darkMode"
                data-icon-light="#lightMode"
                data-sound-src="https://commentari.dev/click.ogg">
                <svg class="icon">
                    <use id="theme-icon"></use>
                </svg>
            </div>
        </nav>

        <main>
            
<article class="post">
    <header class="post-header">
        
        <time datetime="2025-09-07">Published on:
            <span class="accent-data">2025-09-07</span>
        </time>
        

        

        <h1>A first foray into Arrow (Part 1: Python)</h1>
    </header>



    <div class="post-content">
        <p>If we borrow a page from Aristotle, to learn a thing--to understand its causes<sup>[1]</sup>--we must first accumulate practical experience with it and hone our craft; only after can we analyze effectively.</p>
<p>This post begins a short series. We embark with Arrow in Python. Next, I will turn to Arrow in Rust, then survey Arrow's history, and finally, close by developing Arrow's key invariants.</p>
<br>
<hr />
<ol>
<li><a href="https://commentari.dev/software/getting-started-arrow/#hello-columnar"><em>hello columnar</em></a>
<ul>
<li><a href="https://commentari.dev/software/getting-started-arrow/#one-to-two"><em>one row becomes two</em></a></li>
</ul>
</li>
<li><a href="https://commentari.dev/software/getting-started-arrow/#section_2"><em>columns and taking data in stride</em></a>
<ul>
<li><a href="https://commentari.dev/software/getting-started-arrow/#suba"><em>example: table schema</em></a></li>
<li><a href="https://commentari.dev/software/getting-started-arrow/#subb"><em>example: columns</em></a></li>
<li><a href="https://commentari.dev/software/getting-started-arrow/#subc"><em>example: rows</em></a></li>
</ul>
</li>
<li><a href="https://commentari.dev/software/getting-started-arrow/#section_3"><em>records in batches</em></a></li>
<li><a href="https://commentari.dev/software/getting-started-arrow/#section_4"><em>caveat lector</em></a></li>
<li><a href="https://commentari.dev/software/getting-started-arrow/#section_5"><em>parting thoughts</em></a></li>
<li><a href="https://commentari.dev/software/getting-started-arrow/#endnotes"><em>endnotes</em></a></li>
</ol>
<hr />
<br>
<h2 id="hello-columnar">hello columnar</h2>
<p>SQLite<sup>[2]</sup> is a simple row-based runtime. Its minimal configuration keeps Arrow front and center. Arrow is columnar. What does that mean? What does it mean in practice?</p>
<p>Setup for this section:</p>
<ul>
<li><em>have a Python 3 installation</em></li>
<li><em>configure and activate a Python virtual environment</em></li>
<li><code>pip install --upgrade adbc-driver-sqlite adbc-driver-manager pyarrow</code></li>
</ul>
<p>First, we compare the results of a simple select-and-fetch of a single record.</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#65737e;"># hello_db.py
</span><span style="color:#b48ead;">import </span><span>sqlite3 </span><span style="color:#b48ead;">as </span><span>sqlite_rows
</span><span style="color:#b48ead;">from </span><span>adbc_driver_sqlite </span><span style="color:#b48ead;">import </span><span>dbapi </span><span style="color:#b48ead;">as </span><span>sqlite_arrow
</span><span style="color:#65737e;">#    ^ we&#39;ll get to adbc later
</span><span>
</span><span style="color:#bf616a;">QUERY </span><span>= &quot;&quot;&quot;
</span><span style="color:#b48ead;">SELECT
</span><span style="color:#a3be8c;">    </span><span>&#39;</span><span style="color:#a3be8c;">Hello, world!</span><span>&#39; as</span><span style="color:#a3be8c;"> hello,
</span><span style="color:#a3be8c;">    </span><span style="color:#d08770;">1 </span><span>as</span><span style="color:#a3be8c;"> one,
</span><span style="color:#a3be8c;">    length(</span><span>&#39;</span><span style="color:#a3be8c;">hi</span><span>&#39;</span><span style="color:#a3be8c;">) </span><span>as</span><span style="color:#a3be8c;"> two
</span><span>&quot;&quot;&quot;
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">hello_db</span><span>(</span><span style="color:#bf616a;">db_api</span><span>):
</span><span>    </span><span style="color:#b48ead;">with </span><span>db_api.</span><span style="color:#bf616a;">connect</span><span>(&quot;</span><span style="color:#a3be8c;">:memory:</span><span>&quot;) </span><span style="color:#b48ead;">as </span><span>connection:
</span><span>        cursor = connection.</span><span style="color:#bf616a;">cursor</span><span>()
</span><span>        </span><span style="color:#b48ead;">try</span><span>:
</span><span>            cursor.</span><span style="color:#bf616a;">execute</span><span>(</span><span style="color:#bf616a;">QUERY</span><span>)
</span><span>            row = cursor.</span><span style="color:#bf616a;">fetchone</span><span>()
</span><span>            </span><span style="color:#b48ead;">return </span><span>row
</span><span>        </span><span style="color:#b48ead;">finally</span><span>:
</span><span>            cursor.</span><span style="color:#bf616a;">close</span><span>()
</span><span>
</span><span>sqlite_res = </span><span style="color:#bf616a;">hello_db</span><span>(sqlite_rows)
</span><span>arrow_res  = </span><span style="color:#bf616a;">hello_db</span><span>(sqlite_arrow)
</span><span>
</span><span style="color:#96b5b4;">print</span><span>(</span><span style="color:#b48ead;">f</span><span>&quot;</span><span style="color:#a3be8c;">Row-based SQLite:             </span><span>{sqlite_res}&quot;)
</span><span style="color:#96b5b4;">print</span><span>(</span><span style="color:#b48ead;">f</span><span>&quot;</span><span style="color:#a3be8c;">Arrow Standard:               </span><span>{arrow_res}&quot;)
</span></code></pre>
<p>What is the output of this script?</p>
<pre data-lang="shell" style="background-color:#2b303b;color:#c0c5ce;" class="language-shell "><code class="language-shell" data-lang="shell"><span>$ python hello_db.py
</span><span>Row-based SQLite:             (&#39;Hello, world!&#39;, 1, 2)
</span><span>Arrow Standard:               (&#39;Hello, world!&#39;, 1, 2)
</span></code></pre>
<p>We print the data values. The DB-API 2.0 SQLite driver gives a row. In Python, that row is a <code>Tuple</code>. Meanwhile, the Arrow standard hands us...a row?</p>
<p>Sometimes, types say more. Log more type information.</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#96b5b4;">print</span><span>(</span><span style="color:#b48ead;">f</span><span>&quot;</span><span style="color:#a3be8c;">Row-based SQLite row type:    </span><span>{</span><span style="color:#96b5b4;">type</span><span>(sqlite_res)}&quot;)
</span><span style="color:#96b5b4;">print</span><span>(</span><span style="color:#b48ead;">f</span><span>&quot;</span><span style="color:#a3be8c;">Arrow Standard row type:      </span><span>{</span><span style="color:#96b5b4;">type</span><span>(arrow_res)}&quot;)
</span><span>
</span><span style="color:#96b5b4;">print</span><span>()
</span><span style="color:#96b5b4;">print</span><span>(&quot;</span><span style="color:#a3be8c;">Row-based SQLite data types: </span><span>&quot;, [</span><span style="color:#96b5b4;">type</span><span>(x) </span><span style="color:#b48ead;">for </span><span>x </span><span style="color:#b48ead;">in </span><span>sqlite_res])
</span><span style="color:#96b5b4;">print</span><span>(&quot;</span><span style="color:#a3be8c;">Arrow Standard data types:   </span><span>&quot;, [</span><span style="color:#96b5b4;">type</span><span>(x) </span><span style="color:#b48ead;">for </span><span>x </span><span style="color:#b48ead;">in </span><span>arrow_res])
</span></code></pre>
<p>This tells us almost nothing.<sup>[3]</sup></p>
<pre data-lang="text" style="background-color:#2b303b;color:#c0c5ce;" class="language-text "><code class="language-text" data-lang="text"><span>Row-based SQLite row type:    &lt;class &#39;tuple&#39;&gt;
</span><span>Arrow Standard row type:      &lt;class &#39;tuple&#39;&gt;
</span><span>
</span><span>Row-based SQLite data types:  [&lt;class &#39;str&#39;&gt;, &lt;class &#39;int&#39;&gt;, &lt;class &#39;int&#39;&gt;]
</span><span>Arrow Standard data types:    [&lt;class &#39;str&#39;&gt;, &lt;class &#39;int&#39;&gt;, &lt;class &#39;int&#39;&gt;]
</span></code></pre>
<p>On the surface, Arrow looks no different. The values are the same. Their origins are not.</p>
<p>The standard sqlite3 implementation built a Python tuple from a database row. Arrow does something subtler.</p>
<p>This difference is clearer with multiple records.</p>
<h3 id="one-to-two">one row becomes two</h3>
<p>First, add a second row to the result set.</p>
<pre data-lang="diff" style="background-color:#2b303b;color:#c0c5ce;" class="language-diff "><code class="language-diff" data-lang="diff"><span>QUERY = &quot;&quot;&quot;
</span><span>SELECT
</span><span>    &#39;Hello, world!&#39; as hello,
</span><span>    1 as one,
</span><span>    length(&#39;hi&#39;) as two
</span><span style="color:#a3be8c;">+ union all
</span><span style="color:#a3be8c;">+ SELECT
</span><span style="color:#a3be8c;">+    &#39;Hello, again!&#39; as hello,
</span><span style="color:#a3be8c;">+    1+0 as one,
</span><span style="color:#a3be8c;">+    1 &lt;&lt; 1 as two
</span><span>&quot;&quot;&quot;
</span></code></pre>
<p>Second, fetch both rows (or more if they existed) as a <code>List[Row]</code>. This row list represents a database table.</p>
<pre data-lang="diff" style="background-color:#2b303b;color:#c0c5ce;" class="language-diff "><code class="language-diff" data-lang="diff"><span style="color:#bf616a;">-        row = cursor.fetchone()
</span><span style="color:#bf616a;">-        return row
</span><span style="color:#a3be8c;">+        table = cursor.fetchall()
</span><span style="color:#a3be8c;">+        return table
</span></code></pre>
<p>Run it back.</p>
<pre data-lang="shell" style="background-color:#2b303b;color:#c0c5ce;" class="language-shell "><code class="language-shell" data-lang="shell"><span>$ python hello_db_redux.py
</span><span>Row-based SQLite table:       [(&#39;Hello, world!&#39;, 1, 2), (&#39;Hello, again!&#39;, 1, 2)]
</span><span>Arrow Standard table:         [(&#39;Hello, world!&#39;, 1, 2), (&#39;Hello, again!&#39;, 1, 2)]
</span></code></pre>
<p>Again, no visible difference. The solution is to use PyArrow's Arrow-specific functions.</p>
<pre data-lang="diff" style="background-color:#2b303b;color:#c0c5ce;" class="language-diff "><code class="language-diff" data-lang="diff"><span>def hello_db(db_api):
</span><span>    with db_api.connect(&quot;:memory:&quot;) as connection:
</span><span>        cursor = connection.cursor()
</span><span>        try:
</span><span>            cursor.execute(QUERY)
</span><span style="color:#bf616a;">-           table = cursor.fetchall()
</span><span style="color:#a3be8c;">+           table = cursor.fetchallarrow()
</span><span>            return table
</span><span>        finally:
</span><span>            cursor.close()
</span><span>
</span><span style="color:#bf616a;">-sqlite_res = hello_db(sqlite_rows)
</span><span>arrow_res  = hello_db(sqlite_arrow)
</span><span>
</span><span style="color:#bf616a;">-print(f&quot;Row-based SQLite table:       {sqlite_res}&quot;)
</span></code></pre>
<p>Third time's the charm.</p>
<pre data-lang="shell" style="background-color:#2b303b;color:#c0c5ce;" class="language-shell "><code class="language-shell" data-lang="shell"><span>Arrow Standard:   pyarrow.Table
</span><span>hello: string
</span><span>one: int64
</span><span>two: int64
</span><span>----
</span><span>hello: [[&quot;Hello, world!&quot;,&quot;Hello, again!&quot;]]
</span><span>one: [[1,1]]
</span><span>two: [[2,2]]
</span></code></pre>
<p>We are given the table type--now <code>pyarrow.Table</code>--along with the table's schema and a columnar view of its data.</p>
<p>Arrow stores each column in a contiguous, type-homogeneous array<sup>[4]</sup>. In our example, all fields of the <code>hello</code> column are packaged into a String array of length 2; the values of column <code>one</code> are contained in an Integer array of length 2 (likewise for column two). This is the tangible essence of "columnar."</p>
<table><thead><tr><th>hello</th><th>one</th><th>two</th></tr></thead><tbody>
<tr><td>Hello, world!</td><td>1</td><td>2</td></tr>
<tr><td>Hello, again!</td><td>1</td><td>2</td></tr>
</tbody></table>
<p>Row-based implementations group values together horizontally, in tuples.</p>
<pre data-lang="text" style="background-color:#2b303b;color:#c0c5ce;" class="language-text "><code class="language-text" data-lang="text"><span>row-oriented layout (tuples of references in memory)
</span><span>
</span><span>+---------------------------+
</span><span>| (&quot;Hello, world!&quot;, 1, 2)   |
</span><span>+---------------------------+
</span><span>| (&quot;Hello, again!&quot;, 1, 2)   |
</span><span>+---------------------------+
</span></code></pre>
<p>Columnar standards think in groups of columns.</p>
<pre data-lang="text" style="background-color:#2b303b;color:#c0c5ce;" class="language-text "><code class="language-text" data-lang="text"><span>column-oriented layout (contiguous buffers in memory)
</span><span>
</span><span>hello: [&quot;Hello, world!&quot;, &quot;Hello, again!&quot;]
</span><span>one:   [1, 1]
</span><span>two:   [2, 2]
</span></code></pre>
<p>This is the what. The bytes tell us why.
<br></p>
<h2 id="section_2">columns and taking data in stride</h2>
<p>The following examples use this setup.</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#65737e;"># arrow_examples.py
</span><span style="color:#b48ead;">from </span><span>adbc_driver_sqlite </span><span style="color:#b48ead;">import </span><span>dbapi </span><span style="color:#b48ead;">as </span><span>sqlite_arrow
</span><span>
</span><span style="color:#bf616a;">QUERY </span><span>= &quot;&quot;&quot;
</span><span style="color:#b48ead;">SELECT
</span><span style="color:#a3be8c;">    </span><span>&#39;</span><span style="color:#a3be8c;">Hello, world!</span><span>&#39; as</span><span style="color:#a3be8c;"> hello,
</span><span style="color:#a3be8c;">    </span><span style="color:#d08770;">1 </span><span>as</span><span style="color:#a3be8c;"> one,
</span><span style="color:#a3be8c;">    length(</span><span>&#39;</span><span style="color:#a3be8c;">hi</span><span>&#39;</span><span style="color:#a3be8c;">) </span><span>as</span><span style="color:#a3be8c;"> two
</span><span style="color:#b48ead;">union all
</span><span style="color:#b48ead;">SELECT
</span><span style="color:#a3be8c;">    </span><span>&#39;</span><span style="color:#a3be8c;">Hello, again!</span><span>&#39; as</span><span style="color:#a3be8c;"> hello,
</span><span style="color:#a3be8c;">    </span><span style="color:#d08770;">1</span><span>+</span><span style="color:#d08770;">0 </span><span>as</span><span style="color:#a3be8c;"> one,
</span><span style="color:#a3be8c;">    </span><span style="color:#d08770;">1 </span><span>&lt;&lt; </span><span style="color:#d08770;">1 </span><span>as</span><span style="color:#a3be8c;"> two
</span><span>&quot;&quot;&quot;
</span><span>
</span><span>connection = sqlite_arrow.</span><span style="color:#bf616a;">connect</span><span>(&quot;</span><span style="color:#a3be8c;">:memory:</span><span>&quot;)
</span><span>cursor = connection.</span><span style="color:#bf616a;">cursor</span><span>()
</span><span>
</span><span>cursor.</span><span style="color:#bf616a;">execute</span><span>(QUERY.</span><span style="color:#bf616a;">strip</span><span>())
</span><span>table = cursor.</span><span style="color:#bf616a;">fetchallarrow</span><span>()
</span></code></pre>
<h4 id="suba">see table schema (type information)</h4>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#96b5b4;">print</span><span>(table.schema)
</span></code></pre>
<p>A table's schema defines its structure. Part of that structure are columns, and each column has a type. In Arrow, types belong to a rich type system optimized for efficient cross-language representation.</p>
<pre data-lang="text" style="background-color:#2b303b;color:#c0c5ce;" class="language-text "><code class="language-text" data-lang="text"><span>hello: string
</span><span>one: int64
</span><span>two: int64
</span></code></pre>
<p>We see two categories here: primitive scalars (e.g. <code>i64</code>) and variable-length types (e.g. <code>string</code>).</p>
<p>In creating a formal specification, Arrow gives users a logical <em>lingua franca</em> and <em>carte blanche</em> to optimize types in memory. Contiguous memory cells translate to vectorization (cf. faster loads). Boolean values are bit-packed (1 bit per value!!). I am personally inspired by the engineering in this layer alone.<sup>[5]</sup></p>
<p>Note other types:</p>
<ul>
<li>structured data types (e.g. <code>list&lt;T&gt;</code>)</li>
<li>temporal types (e.g. <code>date32</code>, <code>time64</code>)</li>
<li>fixed width decimals</li>
<li>a full suite of scalars including floats</li>
</ul>
<h4 id="subb">grab an entire column</h4>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#96b5b4;">print</span><span>(table[&quot;</span><span style="color:#a3be8c;">one</span><span>&quot;])  </span><span style="color:#65737e;"># pyarrow.ChunkedArray
</span></code></pre>
<p><code>pyarrow</code> can obtain columns by name.</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span> [
</span><span>  [
</span><span>    1,
</span><span>    1
</span><span>  ]
</span><span>]
</span></code></pre>
<p>This operation is zero-copy.<sup>[6]</sup> In Arrow, each column is stored in contiguous memory blocks. To "get the column," Arrow simply returns a new view pointing at the same buffers—no data are copied. So, why is the type logged above <strong>ChunkedArray</strong>?</p>
<p>Imagine we have an <code>int64</code> column. It might exist in memory as several chunks.</p>
<pre data-lang="text" style="background-color:#2b303b;color:#c0c5ce;" class="language-text "><code class="language-text" data-lang="text"><span>ChunkedArray (logical column)
</span><span>        |
</span><span>        +-------------------------------+
</span><span>        |           |           |       |
</span><span>      Array       Array       Array   ...
</span><span>     (len=3)     (len=2)     (len=4)
</span><span>
</span><span>Array #1 → [1, 2, 3]
</span><span>Array #2 → [4, 5]
</span><span>Array #3 → [6, 7, 8, 9]
</span><span>
</span><span>Logical column = [1, 2, 3, 4, 5, 6, 7, 8, 9]
</span></code></pre>
<p>A <strong>ChunkedArray</strong> looks like one continuous column. In truth, it may be split into many chunks. This spec is performant by design. Most systems produce data in batches. Arrow keeps those batches in memory as they come, without copying, without merging. You see a single, seamless column.</p>
<p>Now, back to the code at the section heading.</p>
<pre data-lang="text" style="background-color:#2b303b;color:#c0c5ce;" class="language-text "><code class="language-text" data-lang="text"><span>Arrow Array (view object)
</span><span>+--------------------------------+
</span><span>| type: int64                    |
</span><span>| length: 2                      |
</span><span>| offset: 0                      |
</span><span>| buffers:                       |
</span><span>|   [0] validity bitmap -------+ |
</span><span>|   [1] values buffer pointer -+ |
</span><span>+--------------------------------+
</span><span>
</span><span>Elsewhere in memory:
</span><span>values buffer (contiguous int64):
</span><span>  01 00 00 00 00 00 00 00
</span><span>  01 00 00 00 00 00 00 00
</span><span># logical view → [1, 1]
</span></code></pre>
<p>The column <code>one</code> has only a single Array, so the <strong>ChunkedArray</strong> is just a thin wrapper around that one chunk.</p>
<p>An Arrow Array is not a literal array of values. It is a descriptor: buffers plus metadata like length, offset, and type. When you iterate or slice, Arrow does not have to touch or copy values. The underlying values stay in place. The buffers do not move.</p>
<p>Row-oriented systems are heavier. Each row's fields sit side by side in memory. To pull out a column, you must allocate a new buffer. Then, you walk every row, fetch the field, and copy it. With larger data you may need arrays of pointers. If the row count is unknown, the buffer may overflow and must grow. That means dynamic reallocations and more copying.<sup>[7]</sup></p>
<h4 id="subc">grab a (one) row (table view)</h4>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#96b5b4;">print</span><span>(table.</span><span style="color:#bf616a;">slice</span><span>(</span><span style="color:#d08770;">1</span><span>))
</span></code></pre>
<p>Arrow is quite clever here.</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>hello: [[&quot;Hello, again!&quot;]]
</span><span>one: [[1]]
</span><span>two: [[2]]
</span></code></pre>
<p><code>Table.slice</code> returns another Table. Again, this is zero-copy. The Table returned by <code>table.slice(1)</code> is just a logical view. Precisely, the starting Table and the second obtained from slicing are collections of fat pointers (Arrow Array = metadata + buffer references). The total number matches the number of columns in the schema.</p>
<p>When dealing with database objects millions of records long, skipping the extra copy (or <em>copies</em>) to access a column means significant time and cost savings.</p>
<p>It also practices good systems hygiene: do not move or transform data until you must.</p>
<h2 id="section_3">records in batches</h2>
<p>The abstractions so far stand on their own. They are fast and memory-thrifty. They also set the stage for how systems operate. Systems receive data in pieces. Results do not show up all at once. Arrow’s answer to this is the <strong>RecordBatch</strong>.</p>
<p>Earlier, we contrasted rows and columns:</p>
<table><thead><tr><th>hello</th><th>one</th><th>two</th></tr></thead><tbody>
<tr><td>Hello, world!</td><td>1</td><td>2</td></tr>
<tr><td>Hello, again!</td><td>1</td><td>2</td></tr>
</tbody></table>
<p>A <strong>RecordBatch</strong> is this block viewed columnar &amp; a metadata schema. It is, in Rust parlance, a kind of fat pointer. It points to buffers of data and explains how they fit together as a table.</p>
<pre data-lang="text" style="background-color:#2b303b;color:#c0c5ce;" class="language-text "><code class="language-text" data-lang="text"><span>RecordBatch
</span><span>  schema: {hello: string, one: int64, two: int64}
</span><span>  columns:
</span><span>    hello → Arrow Array (length N)
</span><span>    one   → Arrow Array (length N)
</span><span>    two   → Arrow Array (length N)
</span><span>  other_metadata
</span></code></pre>
<p>Like an Array, a RecordBatch does not own data. It points to column arrays and adds just enough metadata to bind them into a batch of rows.</p>
<p>A <strong>Table</strong> in Arrow is then a sequence of <strong>RecordBatches</strong>. Put another way, a Table is a logical view over several <strong>Record Batches</strong>. Each <strong>RecordBatch</strong> contributes one chunk per column. Put together, they form seamless <strong>ChunkedArrays</strong>:</p>
<p>In Arrow, a table is not a naive list of rows. It is a microcosm of abstractions to achieve.</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>Table (logical view)
</span><span>   ├─ RecordBatch #1 (2 rows)
</span><span>   │    hello → [&quot;Hello, world!&quot;, &quot;Hello, again!&quot;]
</span><span>   │    one   → [1, 1]
</span><span>   │    two   → [2, 2]
</span><span>   │
</span><span>   └─ RecordBatch #2 (3 rows)
</span><span>        hello → [&quot;salve&quot;, &quot;χαῖρε&quot;, &quot;SALAVS&quot;]
</span><span>        one   → [1, 8, 9]
</span><span>        two   → [14, 16, 18]
</span><span>
</span><span>Logical column &quot;one&quot; = [1, 1, 1, 8, 9]
</span></code></pre>
<p>When two RecordBatches share the same schema, you can assemble them into one logical dataset.</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>import pyarrow as pa
</span><span>
</span><span># rb1, rb2: RecordBatch with identical schemas; zero-copy stitching
</span><span>t = pa.Table.from_batches([rb1, rb2])
</span><span># optional: make each column a single contiguous chunk; requires a copy
</span><span>t = t.combine_chunks()
</span></code></pre>
<p>Note the flexibility. RecordBatch gifts us that. It also makes Arrow streaming-ready (receive chunks asynchronously). And of course, it is analytics-ready, since we have the ability to treat several RecordBatches as one table.</p>
<br>
<h2 id="section_4">caveat lector!</h2>
<p>In these examples, we used SQLite as the source engine. SQLite is still a row-based runtime. Arrow comes in only at the hand-off where the driver materializes results. Thus, our examples are <em>Arrow at the edge</em>, and not Arrow <em>all the way down</em>. The in-memory layout we explored is genuine Arrow. The engine is still building rows, however. Formats like ipc enable smooth columnar-native handoff of payloads between processes.</p>
<p>Arrow is also designed for interoperability. Any Arrow object in Python can be converted to rows for use in <code>Pandas</code>, <code>NumPy</code>, or similar. Those first <code>fetchone</code> prints--where an Arrow cursor returned a plain Python tuple--are examples of that. Arrow data lives in columnar buffers, but PyArrow makes it trivial to expose them as rows when needed.</p>
<p>The catch: conversion to rows means new Python objects. This suits debugging or small workloads. But, the real performance gains of Arrow come from staying columnar as long as possible.</p>
<br />
<h2 id="section_5">parting thoughts</h2>
<p>This write-up is a foothold into the Arrow way of thinking. Arrow shines in columnar workloads. Rows are there when you need them, but its real strength is in columns, arrays, and batches. PyArrow makes that model approachable, and the best way to internalize it is to play with the API yourself.</p>
<p>Here, we stayed high-level: what a Table is, how Arrays and ChunkedArrays behave, and why RecordBatch is the core unit. In Part 2, we will switch to Rust and drop closer to the metal.</p>
<p>For now, the takeaway is this: Arrow at first looks familiar, but its engineering is informed by the hard realities of data at scale. This becomes only more clear the deeper we dive.</p>
<hr />
<br>
<h2 id="endnotes"><em>endnotes</em></h2>
<ol>
<li>The traditional English gloss for <em>αἱ αἰτῐ́αι</em>.</li>
<li>Ordinary CPython distributions include the <code>sqlite3</code> module (via pysqlite).</li>
<li>There's a certain kind of engineer who will ask 'why not use <code>fetchall</code>.' But even then the returns will be the same, this time, <code>List</code> with a <code>Row</code> type.</li>
<li>type-homogeneous: all values in the collection are of a single, shared type; this is an oversimplification, as columns are stored as "contiguous buffers." We'll talk more about this in Part 2 in Rust.</li>
<li>Arrow <code>BooleanArray</code> <a href="https://github.com/apache/arrow-rs/blob/d9a4b39815de52a15ca84b392a39fdf422361718/arrow-array/src/array/boolean_array.rs#L68">source</a> for those immediately curious. This is an accessible implementation detail that speaks to what Arrow does under the hood.</li>
<li>zero-copy: Zero-copy means accessing or transferring data without creating a new copy of the underlying bytes. I need to write a blog post that celebrates this property one day. Here in Python, views are zero-copy; materialization (e.g., converting to lists/dataframes) allocates.</li>
<li>There are mitigation strategies like overallocating upfront or maintaining row counts.</li>
</ol>

    </div>

    
</article>

        </main>

        <footer>
            <hr>
<div id="footer-container">
    <p>Made using <a target="_blank" rel="noopener noreferrer" href="https://github.com/Speyll/anemone">anemone</a> Zola theme</p>
</div>

        </footer>

        <!-- Move JS to end of body and add defer -->
        <script src="https://commentari.dev/js/script.js" defer></script>
    </body>
</html>
